import yaml
import re
import os
import subprocess

# Load inventory YAML file
script_dir = os.path.dirname(os.path.abspath(__file__))
inventory_file = os.path.join(script_dir, '..', 'prod', 'inventory.prod.yaml')

def load_inventory_groups():
    """Load server group mappings from the YAML file."""
    with open(inventory_file, 'r') as file:
        inventory = yaml.safe_load(file)

    group_mappings = {}
    
    # Extract all server groups from YAML
    all_groups = inventory.get('all', {}).get('children', {})

    # Loop through groups and extract host-to-group mappings
    for group, group_data in all_groups.items():
        if "hosts" in group_data and isinstance(group_data["hosts"], dict):
            for server, details in group_data["hosts"].items():
                if isinstance(details, dict) and "group" in details:
                    group_mappings[server] = details["group"]  # Assign server to its group

    return group_mappings

def get_efs_server_output():
    """Executes the command and returns parsed EFS server details dynamically."""
    cmd = "efs display efsserver | awk 'NR>3 {print $2 \" \" $1 \" \" $3 \" \" $4}'"
    result = subprocess.run(cmd, shell=True, capture_output=True, text=True, check=True)

    servers = []
    for line in result.stdout.strip().split("\n"):
        parts = line.strip().split()
        if len(parts) >= 4:  # Ensure it has server_name, domain, host_type, group
            server_name = parts[0]  # E.g., laau42efs899
            domain = parts[1]       # E.g., apac.sdi.corp.bankofamerica.com
            host_type = parts[2]    # E.g., dev/prod
            group = parts[3]        # E.g., l_aja_ausyb01sr1
            
            servers.append((server_name, domain, host_type, group))

    return servers

def create_dynamic_pattern_to_group(group_mappings):
    """Dynamically builds PATTERN_TO_GROUP using EFS output and YAML mappings."""
    servers = get_efs_server_output()
    pattern_to_group = {}

    for server_name, _, _, actual_group in servers:
        # Extract pattern prefix (e.g., 'laau42efs' from 'laau42efs899')
        match = re.match(r"([a-z0-9]+)efs", server_name)
        if match:
            pattern = rf"{match.group(1)}efs.*"  # e.g., "laau42efs.*"
            
            # Use YAML mapping if available, else use actual group
            assigned_group = group_mappings.get(server_name, actual_group)
            pattern_to_group[pattern] = assigned_group

    return pattern_to_group

# Load group mappings from YAML
group_mappings = load_inventory_groups()

# Generate the dynamic pattern-to-group mapping
PATTERN_TO_GROUP = create_dynamic_pattern_to_group(group_mappings)

# Load EFS servers dynamically
def load_efs_unique_servers():
    """Load unique EFS servers dynamically from command output."""
    servers = {}
    efs_servers = get_efs_server_output()
    for server, _, host_type, _ in efs_servers:
        servers[server] = host_type  # Store the environment type (dev/prod)

    return servers

# Load EFS servers
efs_servers1 = load_efs_unique_servers()

# Validate server placement
mismatches_servergroup = set()

for server_nm in efs_servers1:
    group = PATTERN_TO_GROUP.get(server_nm, "UNKNOWN_GROUP")
    host_type = efs_servers1[server_nm]

    if server_nm in group_mappings:
        expected_group = group_mappings[server_nm]
        if group != expected_group:
            mismatches_servergroup.add(f"Mismatch: {server_nm} assigned to {group} but expected {expected_group}.")
    
    if host_type == "dev" and "prod" in group:
        mismatches_servergroup.add(f"Mismatch: {server_nm} {host_type} in dev group but should be in prod.")
    elif host_type == "prod" and "dev" in group:
        mismatches_servergroup.add(f"Mismatch: {server_nm} {host_type} in prod group but should be in dev.")

def determine_group_from_pattern(server_name):
    """Determine the group dynamically based on the pattern-to-group mapping."""
    for pattern, group in PATTERN_TO_GROUP.items():
        if re.match(pattern, server_name):
            return group
    return "UNKNOWN_GROUP"  # Default if no match is found

def normalize_cell(cell_name):
    """Normalize cell names to remove inconsistencies (e.g., extra spaces, domain variations)."""
    cell_name = cell_name.strip()  # Remove leading/trailing spaces
    cell_name = re.sub(r'\s+', '', cell_name)  # Remove internal spaces
    cell_name = cell_name.replace(".m1.com", ".ml.com")  # Standardize domain variations
    return cell_name

def compare_cells(efsservers_data, inventory_data):
    """Compare expected and actual cells and print discrepancies to console."""
    
    mismatches = []  # âœ… Initialize mismatches list

    # Identify missing and extra servers
    missing_servers = list(set(efsservers_data.keys()) - set(inventory_data.keys()))
    extra_servers = list(set(inventory_data.keys()) - set(efsservers_data.keys()))

    if missing_servers:
        print("\nMissing servers in inventory:")
        print("==========================================================")
        for server in missing_servers:
            print(f" {server}")

    if extra_servers:
        print("\nServers found in ax_inventories but not in Efs Database or efsserver.txt:")
        print("==========================================================")
        for server in extra_servers:
            print(f" {server}")

    # Validate each server's expected vs actual group
    for server, expected_cells in efsservers_data.items():
        group = determine_group_from_pattern(server)

        if not group:
            print(f"Server {server} does not match any known group.")
            continue

        # Normalize expected and actual cells for comparison
        actual_cells = {normalize_cell(c) for c in inventory_data.get(server, set())}
        expected_cells = {normalize_cell(c) for c in expected_cells}

        if not actual_cells:
            mismatches.append(f"\nMismatch for server: {server} in group {group}:")
            mismatches.append(f" Efs Database: {expected_cells}")
            mismatches.append(f" Ax inventory: (New Server)")
        elif expected_cells != actual_cells:
            missing_cells = expected_cells - actual_cells
            extra_cells = actual_cells - expected_cells

            mismatches.append(f"\n{server} in group {group}:")
            mismatches.append(f" Efs Database: {expected_cells}")
            mismatches.append(f" Ax inventory: {actual_cells}")

            if missing_cells:
                mismatches.append(f" Cells in the Efs Database but not in the Ax inventory: {missing_cells}")
            if extra_cells:
                mismatches.append(f" Cells in the Ax inventory but not in the Efs Database: {extra_cells}")

    if mismatches:
        print("\nControl Group Validation:")
        print("==========================================================")
        print("\n".join(mismatches))
    else:
        print("==========================================================")
        print("Controlgroup A and B are correctly balanced for high availability. \n")

# Validate inventory by comparing EFS servers
def validate_inventory_with_efs():
    """Validate EFS servers against dynamically generated patterns."""
    efsservers_data = load_efs_unique_servers()
    inventory_data = load_inventory_groups()

    compare_cells(efsservers_data, inventory_data)

# Run validation
validate_inventory_with_efs()

# Print dynamically generated mappings for verification
print("\nDynamically Generated PATTERN_TO_GROUP:")
for pattern, group in PATTERN_TO_GROUP.items():
    print(f"{pattern} -> {group}")
