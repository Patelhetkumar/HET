import yaml
import re
import os
import subprocess
import sys
from collections import deque

#################################
# 1) Name & Cell Normalization
#################################

def remove_spaces_in_string(s):
    """
    Removes ALL spaces in a string: "abc . com" -> "abc.com".
    """
    return re.sub(r"\s+", "", s)

def unify_name(full_name):
    """
    1) Remove all spaces from the raw name
    2) Strip everything after the first '.' to remove domain
    3) Lowercase
    4) Remove trailing digits after 'efs|efsd|efsp|pefs|cefs'
       e.g. lauaulcefsp899 -> lauaulcefsp
    """
    full_name = remove_spaces_in_string(full_name)
    short = full_name.split('.', 1)[0].lower()
    short = re.sub(r'(efs[dp]?|pefs|cefs)(\d+)$', r'\1', short)
    return short

def remove_extra_spaces_in_domain(cell):
    """
    Removes weird spacing around dots: 
      "p. usva02. ric. amrs.ml.com" -> "p.usva02.ric.amrs.ml.com"
    and then remove leftover spaces.
    """
    # remove spaces around '.' => "p. usva02. ric" -> "p.usva02.ric"
    cell = re.sub(r"\s*\.\s*", ".", cell)
    # remove leftover multiple spaces
    cell = re.sub(r"\s+", "", cell)
    return cell

def normalize_cell(cell_name):
    """
    - Remove all spaces around dots
    - Convert .m1.com -> .ml.com
    - Lowercase
    """
    cell_name = cell_name.strip().lower()
    cell_name = cell_name.replace(".m1.com", ".ml.com")
    cell_name = remove_extra_spaces_in_domain(cell_name)
    return cell_name

#################################
# 2) EFS Parsing (Storing Raw & Short Names)
#################################

def get_efs_server_output():
    """
    Runs efs display efsserver => lines in format: server, cell, dev/prod, group
    We'll:
      - unify short name for matching
      - store raw EFS name (with all spaces removed) for final mismatch printing
      - store cell sets
    Returns:
      efs_data = { short_name -> set_of_cells }
      efs_raw_map = { short_name -> raw_server_name_without_spaces }
    """
    cmd = """efs display efsserver | sed -e '1,/^==*/d' | awk '{print $2 ", " $1 ", " $3 ", " $4}'"""
    result = subprocess.run(cmd, shell=True, capture_output=True, text=True, check=True)

    efs_data = {}
    efs_raw_map = {}

    for line in result.stdout.strip().split("\n"):
        parts = [p.strip() for p in line.split(",")]
        if len(parts) < 4:
            continue
        raw_srv, raw_cell, _, _ = parts

        # Remove ALL spaces from the raw server name
        raw_srv_no_spaces = remove_spaces_in_string(raw_srv)
        short_srv = unify_name(raw_srv_no_spaces)

        if short_srv not in efs_raw_map:
            efs_raw_map[short_srv] = raw_srv_no_spaces  # keep the fully de-spaced raw name

        cell_val = normalize_cell(raw_cell)
        if short_srv not in efs_data:
            efs_data[short_srv] = set()
        efs_data[short_srv].add(cell_val)

    return efs_data, efs_raw_map

#################################
# 3) BFS Inventory (Storing Raw & Short)
#################################

def load_inventory_anywhere(inventory_file):
    """
    BFS-scans entire inventory.prod.yaml, collecting any 'hosts:' blocks.
    - unify short name for matching
    - store raw name with spaces removed
    - store cells
    Returns:
      inv_data = { short_srv -> set_of_cells }
      inv_raw_map = { short_srv -> raw_server_name_without_spaces }
    """
    if not os.path.isfile(inventory_file):
        print(f"‚ùå Error: Inventory file '{inventory_file}' not found.")
        sys.exit(1)

    with open(inventory_file, 'r') as f:
        doc = yaml.safe_load(f)

    inv_data = {}
    inv_raw_map = {}

    queue = deque([doc])
    while queue:
        node = queue.popleft()
        if isinstance(node, dict):
            # if node has 'hosts'
            hosts = node.get("hosts", {})
            if isinstance(hosts, dict):
                for raw_srv, details in hosts.items():
                    if isinstance(details, dict):
                        # remove spaces from raw server
                        raw_srv_no_spaces = remove_spaces_in_string(raw_srv)
                        short_srv = unify_name(raw_srv_no_spaces)
                        if short_srv not in inv_raw_map:
                            inv_raw_map[short_srv] = raw_srv_no_spaces

                        cell_list = details.get("cells", [])
                        norm_cells = {normalize_cell(c) for c in cell_list}
                        inv_data[short_srv] = norm_cells

            # BFS deeper
            for v in node.values():
                if isinstance(v, dict):
                    queue.append(v)
                elif isinstance(v, list):
                    for item in v:
                        if isinstance(item, dict):
                            queue.append(item)
        elif isinstance(node, list):
            for item in node:
                if isinstance(item, dict):
                    queue.append(item)

    return inv_data, inv_raw_map

#################################
# 4) Compare & Print
#################################

def compare_cells(efs_data, efs_raw_map, inv_data, inv_raw_map):
    """
    Compare EFS vs. Inventory by short name. Then print mismatches with the full raw name
    from EFS if available, else from Inventory, else fallback to short name.
    """
    efs_srvs = set(efs_data.keys())
    inv_srvs = set(inv_data.keys())

    missing_in_inventory = sorted(efs_srvs - inv_srvs)
    missing_in_efs       = sorted(inv_srvs - efs_srvs)

    if missing_in_inventory:
        print("\nServers found in EFS Database but not in ax_inventories:")
        print("==========================================================")
        for short_srv in missing_in_inventory:
            # prefer raw EFS name
            raw_name = efs_raw_map.get(short_srv, short_srv)
            print(raw_name)

    if missing_in_efs:
        print("\nServers found in ax_inventories but not in Efs Database or efsserver.txt:")
        print("==========================================================")
        for short_srv in missing_in_efs:
            # not in EFS, so fallback to inventory raw name
            raw_name = inv_raw_map.get(short_srv, short_srv)
            print(raw_name)

    common = efs_srvs & inv_srvs
    for short_srv in sorted(common):
        efs_cells = efs_data[short_srv]
        inv_cells = inv_data[short_srv]

        if efs_cells != inv_cells:
            # pick a raw name to show:
            if short_srv in efs_raw_map:
                full_name = efs_raw_map[short_srv]
            elif short_srv in inv_raw_map:
                full_name = inv_raw_map[short_srv]
            else:
                full_name = short_srv  # last fallback

            missing_cells = efs_cells - inv_cells
            extra_cells   = inv_cells - efs_cells

            print(f"\nMismatch for server: {full_name}")
            print(f" Efs Database: {efs_cells}")
            print(f" Ax inventory: {inv_cells}")

            if missing_cells:
                print(f" Cells in the Efs Database but not in the Ax inventory: {missing_cells}")
            if extra_cells:
                print(f" Cells in the Ax inventory but not in the Efs Database: {extra_cells}")

#################################
# 5) Orchestrator
#################################

def validate_inventory_with_efs(inventory_file):
    efs_data, efs_raw_map = get_efs_server_output()
    inv_data, inv_raw_map = load_inventory_anywhere(inventory_file)
    compare_cells(efs_data, efs_raw_map, inv_data, inv_raw_map)

def main():
    script_dir = os.path.dirname(os.path.abspath(__file__))
    inventory_file = os.path.join(script_dir, '..', 'prod', 'inventory.prod.yaml')
    validate_inventory_with_efs(inventory_file)

if __name__ == "__main__":
    main()
