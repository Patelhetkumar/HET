import yaml
import re
import os
import subprocess
import sys
from collections import deque

#################################
# 1) Name Normalization
#################################

def unify_name(full_name):
    """
    1) Strip domain (the first '.').
    2) Lowercase.
    3) Remove trailing digits after 'efs', 'efsd', 'efsp', 'pefs', 'cefs'.
    Example: lauaulcefsp899 -> lauaulcefsp
    """
    short = full_name.split('.', 1)[0].lower()
    short = re.sub(r'(efs[dp]?|pefs|cefs)(\d+)$', r'\1', short)
    return short

def remove_extra_spaces_in_domain(cell):
    """
    Removes weird spaces around dots:
      "p. usnj06. nyc. amrs. ml.com" -> "p.usnj06.nyc.amrs.ml.com"
    """
    cell = re.sub(r"\s*\.\s*", ".", cell)
    cell = re.sub(r"\s+", "", cell)
    return cell

def normalize_cell(cell_name):
    """
    Lowercase, strip spaces, .m1.com->.ml.com, remove domain spacing.
    """
    cell_name = cell_name.strip().lower()
    cell_name = cell_name.replace(".m1.com", ".ml.com")
    cell_name = remove_extra_spaces_in_domain(cell_name)
    return cell_name

#################################
# 2) EFS Data Parsing
#################################

def get_efs_server_output():
    """
    Runs 'efs display efsserver' -> lines with 4 columns: (server, cell, dev/prod, group).
    We'll unify the server name for matching, but also store the raw EFS name to display in mismatches.
    
    Returns:
      efs_data = {unified_name -> set of normalized_cells}
      efs_name_map = {unified_name -> original EFS raw server name}
    """
    cmd = """efs display efsserver | sed -e '1,/^==*/d' | awk '{print $2 ", " $1 ", " $3 ", " $4}'"""
    result = subprocess.run(cmd, shell=True, capture_output=True, text=True, check=True)

    efs_data = {}
    efs_name_map = {}  # short_name -> raw EFS name (with domain, digits, etc.)

    for line in result.stdout.strip().split("\n"):
        parts = [p.strip() for p in line.split(",")]
        if len(parts) < 4:
            continue
        raw_server_name, raw_cell, _, _ = parts

        short_name = unify_name(raw_server_name)
        if short_name not in efs_name_map:
            efs_name_map[short_name] = raw_server_name  # keep the first raw name encountered

        cell_val = normalize_cell(raw_cell)
        if short_name not in efs_data:
            efs_data[short_name] = set()
        efs_data[short_name].add(cell_val)

    return efs_data, efs_name_map

#################################
# 3) BFS Inventory Parsing
#################################

def load_inventory_anywhere(inventory_file):
    """
    BFS over the entire YAML doc to find any 'hosts:' keys, storing them in:
      inventory_data   = {unified_name -> set_of_cells}
      inventory_name_map = {unified_name -> raw host name from inventory}
    """
    if not os.path.isfile(inventory_file):
        print(f"❌  Error: Inventory file '{inventory_file}' not found.")
        sys.exit(1)

    with open(inventory_file, 'r') as f:
        doc = yaml.safe_load(f)

    inventory_data = {}
    inventory_name_map = {}  # short_name -> raw inventory name
    queue = deque([doc])

    while queue:
        node = queue.popleft()
        if isinstance(node, dict):
            # If node has 'hosts'
            if "hosts" in node and isinstance(node["hosts"], dict):
                for raw_srv, details in node["hosts"].items():
                    if isinstance(details, dict):
                        short_srv = unify_name(raw_srv)
                        if short_srv not in inventory_name_map:
                            inventory_name_map[short_srv] = raw_srv
                        cell_list = details.get("cells", [])
                        norm_cells = {normalize_cell(c) for c in cell_list}
                        inventory_data[short_srv] = norm_cells

            # BFS deeper
            for v in node.values():
                if isinstance(v, dict):
                    queue.append(v)
                elif isinstance(v, list):
                    for item in v:
                        if isinstance(item, dict):
                            queue.append(item)
        elif isinstance(node, list):
            for item in node:
                if isinstance(item, dict):
                    queue.append(item)

    return inventory_data, inventory_name_map

#################################
# 4) Compare & Print with Full Raw Name
#################################

def compare_cells(efs_data, efs_name_map, inv_data, inv_name_map):
    """
    Prints the mismatch using the full raw server name from EFS if available,
    else if we never saw it in EFS, fallback to the inventory's raw name,
    else fallback to the short name.
    """
    efs_srvs = set(efs_data.keys())
    inv_srvs = set(inv_data.keys())

    missing_in_inventory = sorted(efs_srvs - inv_srvs)
    missing_in_efs       = sorted(inv_srvs - efs_srvs)

    if missing_in_inventory:
        print("\nServers found in EFS Database but not in ax_inventories:")
        print("==========================================================")
        for short_srv in missing_in_inventory:
            # We have a raw EFS name for sure
            raw_efs_name = efs_name_map.get(short_srv, short_srv)
            print(raw_efs_name)

    if missing_in_efs:
        print("\nServers found in ax_inventories but not in Efs Database or efsserver.txt:")
        print("==========================================================")
        for short_srv in missing_in_efs:
            # Not in EFS, so fallback to inventory raw name or short
            raw_inv_name = inv_name_map.get(short_srv, short_srv)
            print(raw_inv_name)

    common = efs_srvs & inv_srvs
    for short_srv in sorted(common):
        efs_cells = efs_data[short_srv]
        inv_cells = inv_data[short_srv]
        if efs_cells != inv_cells:
            # Choose which raw name to show: EFS or Inventory
            # We'll prefer EFS raw name if it exists, else Inventory
            raw_efs_name = efs_name_map.get(short_srv)
            raw_inv_name = inv_name_map.get(short_srv)
            if raw_efs_name:
                full_name = raw_efs_name
            elif raw_inv_name:
                full_name = raw_inv_name
            else:
                full_name = short_srv  # last fallback

            missing_cells = efs_cells - inv_cells
            extra_cells   = inv_cells - efs_cells

            print(f"\nMismatch for server: {full_name}")
            print(f" Efs Database: {efs_cells}")
            print(f" Ax inventory: {inv_cells}")

            if missing_cells:
                print(f" Cells in the Efs Database but not in the Ax inventory: {missing_cells}")
            if extra_cells:
                print(f" Cells in the Ax inventory but not in the Efs Database: {extra_cells}")

#################################
# 5) Main Orchestrator
#################################

def validate_inventory_with_efs(inventory_file):
    efs_data, efs_name_map = get_efs_server_output()
    inv_data, inv_name_map = load_inventory_anywhere(inventory_file)
    compare_cells(efs_data, efs_name_map, inv_data, inv_name_map)

def main():
    script_dir = os.path.dirname(os.path.abspath(__file__))
    inventory_file = os.path.join(script_dir, '..', 'prod', 'inventory.prod.yaml')
    validate_inventory_with_efs(inventory_file)

if __name__ == "__main__":
    main()
