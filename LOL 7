import yaml
import re
import os
import sys
import subprocess
from collections import deque

###############################################################################
# 1) Normalization Helpers
###############################################################################

def remove_all_spaces(s: str) -> str:
    """Remove all whitespace from a string."""
    return re.sub(r"\s+", "", s)

def unify_server_name(full_name: str) -> str:
    """
    1) Remove all spaces
    2) Lowercase
    3) Strip domain after first '.'
    4) Remove trailing digits after efs/efsd/efsp/pefs/cefs
    """
    s = remove_all_spaces(full_name).lower()
    parts = s.split('.', 1)
    short = parts[0] if parts else s
    short = re.sub(r'(efs[dp]?|pefs|cefs)(\d+)$', r'\1', short)
    return short

def normalize_cell(cell_name: str) -> str:
    """
    Remove all spaces, lowercase, fix .m1.com -> .ml.com, etc.
    """
    c = remove_all_spaces(cell_name).lower()
    c = c.replace(".m1.com", ".ml.com")
    return c

###############################################################################
# 2) EFS Parsing (4 columns)
###############################################################################

def get_efs_server_output():
    cmd = """efs display efsserver | sed -e '1,/^==*/d' | awk '{print $2 ", " $1 ", " $3 ", " $4}'"""
    result = subprocess.run(cmd, shell=True, capture_output=True, text=True, check=True)

    efs_data = {}    # { short_name -> set_of_cells }
    efs_raw  = {}    # { short_name -> raw EFS server name (no spaces) }

    for line in result.stdout.strip().split("\n"):
        parts = [p.strip() for p in line.split(",")]
        if len(parts) < 4:
            continue

        raw_srv, raw_cell, _, _ = parts
        short_srv = unify_server_name(raw_srv)
        no_space_srv = remove_all_spaces(raw_srv)

        if short_srv not in efs_raw:
            efs_raw[short_srv] = no_space_srv

        cell_val = normalize_cell(raw_cell)
        efs_data.setdefault(short_srv, set()).add(cell_val)

    return efs_data, efs_raw

###############################################################################
# 3) BFS Inventory, capturing both cells AND group name
###############################################################################

def bfs_load_inventory_with_groups(inventory_file):
    """
    BFS scan to find all 'hosts:' blocks. For each server:
      - unify short name
      - store { short_name -> (groupName, set_of_cells) }
    We'll treat the dictionary key as the 'group' if it has a 'hosts:' subdict.
    """
    if not os.path.isfile(inventory_file):
        print(f"❌  Error: file not found: {inventory_file}")
        sys.exit(1)

    with open(inventory_file, "r") as f:
        doc = yaml.safe_load(f)

    inv_data = {}       # { short_srv -> (group_name, set_of_cells) }
    inv_raw_map = {}    # { short_srv -> raw inventory server name (no spaces) }

    queue = deque([(doc, "root")])  # store (node, parent_key)

    while queue:
        node, parent_key = queue.popleft()
        if isinstance(node, dict):
            # If node has 'hosts'
            if "hosts" in node and isinstance(node["hosts"], dict):
                # This parent's key might be our group name
                group_name = parent_key
                # parse each host
                for raw_srv, details in node["hosts"].items():
                    if isinstance(details, dict):
                        short_srv = unify_server_name(raw_srv)
                        no_space_inv = remove_all_spaces(raw_srv)
                        if short_srv not in inv_raw_map:
                            inv_raw_map[short_srv] = no_space_inv

                        cell_list = details.get("cells", [])
                        norm_cells = {normalize_cell(c) for c in cell_list}

                        # store as (groupName, set_of_cells)
                        inv_data[short_srv] = (group_name, norm_cells)

            # BFS deeper
            for k, v in node.items():
                if isinstance(v, dict):
                    # pass child_key as next parent's name
                    queue.append((v, k)) 
                elif isinstance(v, list):
                    for item in v:
                        if isinstance(item, dict):
                            # we keep the same parent_key
                            queue.append((item, parent_key))

        elif isinstance(node, list):
            for item in node:
                if isinstance(item, dict):
                    queue.append((item, parent_key))

    return inv_data, inv_raw_map

###############################################################################
# 4) Compare & Print with Group Info
###############################################################################

def compare_cells_with_groups(efs_data, efs_raw, inv_data, inv_raw):
    """
    inv_data: { short_name -> (groupName, set_of_cells) }
    efs_data: { short_name -> set_of_cells }
    We'll produce mismatch lines that say "Mismatch for server: raw_name in group {groupName}:"
    """
    efs_srvs = set(efs_data.keys())
    inv_srvs = set(inv_data.keys())

    missing_in_inventory = sorted(efs_srvs - inv_srvs)
    missing_in_efs       = sorted(inv_srvs - efs_srvs)

    if missing_in_inventory:
        print("\nServers found in EFS Database but not in ax_inventories:")
        print("==========================================================")
        for short_srv in missing_in_inventory:
            raw_efs_name = efs_raw.get(short_srv, short_srv)
            print(raw_efs_name)

    if missing_in_efs:
        print("\nServers found in ax_inventories but not in Efs Database or efsserver.txt:")
        print("==========================================================")
        for short_srv in missing_in_efs:
            # might not have a raw inventory name, fallback to short
            groupName, _ = inv_data[short_srv]
            raw_inv_name = inv_raw.get(short_srv, short_srv)
            print(raw_inv_name)

    common = efs_srvs & inv_srvs
    for short_srv in sorted(common):
        efs_cells = efs_data[short_srv]

        groupName, inv_cells = inv_data[short_srv]
        raw_efs_name = efs_raw.get(short_srv)
        raw_inv_name = inv_raw.get(short_srv)

        # Which raw name do we display? Prefer EFS raw if it exists
        if raw_efs_name:
            display_name = raw_efs_name
        elif raw_inv_name:
            display_name = raw_inv_name
        else:
            display_name = short_srv

        if efs_cells != inv_cells:
            missing_cells = efs_cells - inv_cells
            extra_cells   = inv_cells - efs_cells

            print(f"\nMismatch for server: {display_name} in group {groupName}:")
            print(f" Efs Database: {efs_cells}")
            print(f" Ax inventory: {inv_cells}")
            if missing_cells:
                print(f" Cells in the Efs Database but not in the Ax inventory: {missing_cells}")
            if extra_cells:
                print(f" Cells in the Ax inventory but not in the Efs Database: {extra_cells}")

###############################################################################
# 5) Orchestrator
###############################################################################

def validate_inventory_with_efs(inventory_file):
    efs_data, efs_raw = get_efs_server_output()
    inv_data, inv_raw = bfs_load_inventory_with_groups(inventory_file)
    compare_cells_with_groups(efs_data, efs_raw, inv_data, inv_raw)

def main():
    script_dir = os.path.dirname(os.path.abspath(__file__))
    inv_file = os.path.join(script_dir, "..", "prod", "inventory.prod.yaml")
    validate_inventory_with_efs(inv_file)

if __name__ == "__main__":
    main()
